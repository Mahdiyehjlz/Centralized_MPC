clear;
close all;
clc;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% ---------------------import libraries--------------------------%
import casadi.*


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% -------------Dynamics-------------------%%

% this dynamic using SX is only to use in casadi and different from matlab
% mathematic toolbox that we were using syms
% this is easier and better
N = 4;
nx = 3*N;
nu = 2*N;

x = SX.sym('x', nx, 1);
u = SX.sym('u', nu, 1);

f_expl = SX.zeros(nx,1);
for i = 1:N
    xi = x(3*(i-1)+1);
    yi = x(3*(i-1)+2);
    thi = x(3*(i-1)+3);
    vi = u(2*(i-1)+1);
    wi = u(2*(i-1)+2);

    f_expl(3*(i-1)+(1:3)) = [vi*cos(thi); vi*sin(thi); wi];
end

% CasADi function to evaluate dynamics (useful for simulation)
f_fun = Function('f_fun', {x, u}, {f_expl});

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% -----------------Individual Line Trajectory Parameters------------%%

% Define individual start and end points for each robot
start_points = [1, 1; 
               1,-1; 
              -1,-1; 
              -1, 1];
          
end_points = [11, 11; 
             11, 9; 
              9, 9; 
              9, 11];

% Desired speed along the line
desired_speed = 1.0; % m/s

% Total simulation time and trajectory duration
Tf = 80;             % total simulation time [s]
trajectory_duration = Tf; % Time to complete the line trajectory

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% -----------------Time-Varying Desired Position Function----------%%

% Function to compute desired formation at time t
get_desired_formation = @(t) get_desired_formation_at_time(t, start_points, end_points,...
                                    trajectory_duration, desired_speed);

% Test the function at initial time
[z_des_initial, centers_des_initial] = get_desired_formation(0);

% Store for later use
z_des = z_des_initial;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% ------------------MPC Parameters------------------------------%%

N_horizon = 60;      % prediction horizon steps
dt = Tf / N_horizon; % sampling time

% Input limits (not enforced here, but values kept)
v_max = 2.0; w_max = 1.0;
v_min = -v_max; w_min = -w_max;

% initial state - use the start points as initial positions
% For heading, use the direction from start to end point for each robot
z0 = zeros(nx, 1);
for i = 1:N
    idx = (i-1)*3 + (1:3);
    z0(idx(1)) = start_points(i, 1);  % x position
    z0(idx(2)) = start_points(i, 2);  % y position
    % Calculate initial heading towards end point
    dx = end_points(i, 1) - start_points(i, 1);
    dy = end_points(i, 2) - start_points(i, 2);
    z0(idx(3)) = atan2(dy, dx);      % heading
end

% weights (quadratic weights)
Q_x = 49.0; Q_y = 49.0; Q_th = 0.1;
R_v = 2.25; R_w = 81;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% -------------------pack casadi symbols----------------------------%
% Create acados model struct compatible with AcadosOcp
model = AcadosModel();
model.x = x;
model.u = u;
model.f_expl_expr = f_expl;
model.name = 'multi_unicycle';

%% --------------------Build Ocp--------------------------------------%%

ocp = AcadosOcp();
ocp.model = model;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% ------------------ Cost Function ---------------------------------%%

% Build weight matrices for each robot
Wx_robot = diag([Q_x, Q_y, Q_th]);
Wu_robot = diag([R_v, R_w]);

% Create block diagonal matrices for all robots
Wx = kron(eye(N), Wx_robot);
Wu = kron(eye(N), Wu_robot);

% Since we have time-varying reference, we'll use a different approach
% We'll create a parameter for the desired state that changes each MPC step

% Add parameter for time-varying reference
ocp.model.p = SX.sym('p', nx, 1);  % Parameter for desired state
z_des_param = ocp.model.p;

% 1. Initial Cost
ocp.cost.cost_type_0 = 'NONLINEAR_LS';
ocp.cost.W_0 = Wu;
ocp.cost.yref_0 = zeros(nu, 1);
ocp.model.cost_y_expr_0 = model.u;

% 2. Path Cost - use parameter for desired state
% Path cost: reference is included as parameter (p)
ocp.cost.cost_type = 'NONLINEAR_LS';
ocp.cost.W = blkdiag(Wx, Wu);

% Now, cost expression is "tracking error" directly
ocp.model.cost_y_expr = vertcat(model.x - z_des_param, model.u); %model.x changed to model.x - z_des_param

% Reference becomes zero (we track relative error, not absolute position)
ocp.cost.yref = zeros(nx + nu, 1);   


% 3. Terminal Cost
ocp.cost.cost_type_e = 'NONLINEAR_LS';
ocp.model.cost_y_expr_e = model.x - z_des_param; %this is also changed
ocp.cost.yref_e = zeros(nx,1);
ocp.cost.W_e = Wx;

%% ------------------ Horizon and Discretization ---------------------%%

ocp.solver_options.tf = Tf;
ocp.solver_options.N_horizon = N_horizon;

%% Constraints
ocp.constraints.x0 = z0;
ocp.constraints.lbu = repmat([v_min; w_min], N, 1);
ocp.constraints.ubu = repmat([v_max; w_max], N, 1);
ocp.constraints.idxbu = 0:(nu-1);

%% Solver options (same as before)
ocp.solver_options.nlp_solver_type = 'SQP_RTI';
ocp.solver_options.integrator_type = 'ERK'; 
ocp.solver_options.qp_solver = 'PARTIAL_CONDENSING_HPIPM'; 
ocp.solver_options.qp_solver_iter_max = 100; 
ocp.solver_options.qp_solver_tol_stat = 1e-6;
ocp.solver_options.qp_solver_tol_eq = 1e-6;
ocp.solver_options.qp_solver_tol_ineq = 1e-6;
ocp.solver_options.qp_solver_tol_comp = 1e-6;
ocp.solver_options.qp_solver_mu0 = 1e-2;
ocp.solver_options.qp_solver_cond_N = N_horizon;
ocp.solver_options.hessian_approx = 'GAUSS_NEWTON'; 
ocp.solver_options.ext_fun_compile_flags = '-O2'; 
ocp.solver_options.nlp_solver_max_iter = 50;
ocp.solver_options.nlp_solver_tol_stat = 1e-4;
ocp.solver_options.nlp_solver_tol_eq = 1e-4;
ocp.solver_options.nlp_solver_tol_ineq = 1e-4;
ocp.solver_options.nlp_solver_tol_comp = 1e-4;
ocp.solver_options.globalization = 'FIXED_STEP';
ocp.solver_options.levenberg_marquardt = 1e-2;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% -------------------Create Acados Solver-------------------------%%

acados_ocp_solver = AcadosOcpSolver(ocp);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% -------------------Simulation Setup-----------------------------%%

% Number of simulation steps
N_sim = 100;
t_sim = linspace(0, Tf, N_sim+1);

% Initialize simulation arrays
z_sim = zeros(nx, N_sim+1);
u_sim = zeros(nu, N_sim);
z_des_history = zeros(nx, N_sim+1);  % Store desired states over time
z_sim(:,1) = z0;

% Initialize cost function storage
cost_values = zeros(1, N_sim);
state_cost_values = zeros(1, N_sim);
control_cost_values = zeros(1, N_sim);
solver_status = zeros(1, N_sim);
solver_iterations = zeros(1, N_sim);
solver_times = zeros(1, N_sim);

% Create quadratic cost function for evaluation
stage_cost_fn = @(x, u, z_des_current) (x - z_des_current)' * Wx * (x - z_des_current) + u' * Wu * u;

% Initialize solver
acados_ocp_solver.set('constr_x0', z0);

% Set initial desired state
z_des_initial = get_desired_formation_at_time(0, start_points, end_points, trajectory_duration, desired_speed);
acados_ocp_solver.set('p', z_des_initial);
z_des_history(:,1) = z_des_initial;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% -------------------Main Simulation Loop-------------------------%%

fprintf('Starting MPC simulation with individual line trajectories...\n');

for k = 1:N_sim
    current_time = t_sim(k);
    
    % Get desired formation at current time
    [z_des_current, centers_current] = get_desired_formation(current_time);
    z_des_history(:,k) = z_des_current;
    
    % Set parameter (desired state) for current optimization
    acados_ocp_solver.set('p', z_des_current);
    
    % Set initial state constraint
    acados_ocp_solver.set('constr_x0', z_sim(:,k));
    
    % Solve OCP
    acados_ocp_solver.solve();
    
    % Get solver statistics
    status = acados_ocp_solver.get('status');
    sqp_iter = acados_ocp_solver.get('sqp_iter');
    time_tot = acados_ocp_solver.get('time_tot');
    
    solver_status(k) = status;
    solver_iterations(k) = sqp_iter;
    solver_times(k) = time_tot;
    
    if status ~= 0
        fprintf('Warning: acados returned status %d at step %d\n', status, k);
    end
    
    % Get optimal control input (first step)
    u_opt = acados_ocp_solver.get('u', 0);
    u_sim(:,k) = u_opt;
    
    % Calculate quadratic cost for current state and applied control
    current_total_cost = stage_cost_fn(z_sim(:,k), u_opt, z_des_current);
    cost_values(k) = current_total_cost;
    
    % Calculate state cost component
    state_cost_val = (z_sim(:,k) - z_des_current)' * Wx * (z_sim(:,k) - z_des_current);
    state_cost_values(k) = state_cost_val;
    
    % Calculate control cost component
    control_cost_val = u_opt' * Wu * u_opt;
    control_cost_values(k) = control_cost_val;
    
    % Simulate system forward (using 4th order Runge-Kutta)
    z_current = z_sim(:,k);
    
    % RK4 integration
    k1 = f_fun(z_current, u_opt);
    k2 = f_fun(z_current + 0.5*dt*k1, u_opt);
    k3 = f_fun(z_current + 0.5*dt*k2, u_opt);
    k4 = f_fun(z_current + dt*k3, u_opt);
    
    z_next = z_current + (dt/6) * (k1 + 2*k2 + 2*k3 + k4);
    z_sim(:,k+1) = full(z_next);
    
    % Print progress
    if mod(k, 10) == 0
        fprintf('Step %d/%d - Time: %.1fs - Cost: %.4f\n', ...
                k, N_sim, current_time, cost_values(k));
    end
end

% Get final desired state
z_des_history(:,end) = get_desired_formation(t_sim(end));

fprintf('Simulation completed successfully!\n');



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% -------------------Helper Function for Time-Varying Formation---%%

function [z_des, centers_des] = get_desired_formation_at_time(t, start_points, end_points, trajectory_duration, desired_speed)
    N = size(start_points, 1);
    nx = 3*N;
    
    z_des = zeros(nx,1);
    centers_des = zeros(2, N);  % Store center for each robot's trajectory
    
    for i = 1:N
        % Calculate progress along the line for this robot (0 to 1)
        if t >= trajectory_duration
            progress = 1.0;  % Reached the end
        else
            progress = t / trajectory_duration;
        end
        
        % Calculate current position along this robot's line
        current_pos = start_points(i,:) + progress * (end_points(i,:) - start_points(i,:));
        centers_des(:,i) = current_pos';
        
        % Calculate desired orientation (aligned with line direction)
        line_vec = end_points(i,:) - start_points(i,:);
        theta_des = atan2(line_vec(2), line_vec(1));
        
        % Build the desired state vector for this robot
        idx = (i-1)*3 + (1:3);
        z_des(idx(1)) = current_pos(1);  % desired x_i
        z_des(idx(2)) = current_pos(2);  % desired y_i
        z_des(idx(3)) = theta_des;       % robot's heading
    end
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% -------------------Plotting Results-----------------------------%%

figure('Position', [100, 100, 1200, 1000]);

% 1. Trajectories in 2D space with individual line trajectories
subplot(2,3,1);
hold on; grid on;
colors = ['r', 'g', 'b', 'm'];

% Plot individual desired line trajectories
t_plot = linspace(0, Tf, 100);
for i = 1:N
    robot_trajectory = zeros(2, length(t_plot));
    for j = 1:length(t_plot)
        [~, centers] = get_desired_formation_at_time(t_plot(j), start_points, end_points, trajectory_duration, desired_speed);
        robot_trajectory(:,j) = centers(:,i);
    end
    plot(robot_trajectory(1,:), robot_trajectory(2,:), [colors(i) '--'], 'LineWidth', 1, 'HandleVisibility', 'off');
end

% Plot robot trajectories
for i = 1:N
    idx = (i-1)*3 + (1:2);
    plot(z_sim(idx(1),:), z_sim(idx(2),:), [colors(i) '-'], 'LineWidth', 2);
    plot(z_sim(idx(1),1), z_sim(idx(2),1), [colors(i) 'o'], 'MarkerSize', 8, 'LineWidth', 2);
    plot(z_des_history(idx(1),end), z_des_history(idx(2),end), [colors(i) 's'], 'MarkerSize', 10, 'LineWidth', 2);
    
    % Plot start and end points for each robot
    plot(start_points(i,1), start_points(i,2), [colors(i) '^'], 'MarkerSize', 8, 'LineWidth', 2);
    plot(end_points(i,1), end_points(i,2), [colors(i) 'x'], 'MarkerSize', 10, 'LineWidth', 2);
end

xlabel('X position'); ylabel('Y position');
title('Individual Robot Trajectories');
legend('Robot 1', 'Start 1', 'Goal 1', 'Start Point 1', 'End Point 1', ...
       'Robot 2', 'Start 2', 'Goal 2', 'Start Point 2', 'End Point 2', ...
       'Robot 3', 'Start 3', 'Goal 3', 'Start Point 3', 'End Point 3', ...
       'Robot 4', 'Start 4', 'Goal 4', 'Start Point 4', 'End Point 4', ...
       'Location', 'best');
axis equal;

% 2. Position errors over time
subplot(2,3,2);
hold on; grid on;
pos_errors = zeros(N, N_sim+1);
for i = 1:N
    idx = (i-1)*3 + (1:2);
    for kk = 1:N_sim+1
        pos_errors(i,kk) = norm(z_sim(idx,kk) - z_des_history(idx,kk));
    end
    plot(t_sim, pos_errors(i,:), [colors(i) '-'], 'LineWidth', 1.5);
end
xlabel('Time [s]'); ylabel('Position Error');
title('Position Errors vs Time');
legend('Robot 1', 'Robot 2', 'Robot 3', 'Robot 4');

% 3. Individual robot progress
subplot(2,3,3);
hold on; grid on;
progress_metrics = zeros(N, N_sim+1);

for i = 1:N
    for kk = 1:N_sim+1
        idx = (i-1)*3 + (1:2);
        current_pos = z_sim(idx, kk);
        start_pos = start_points(i,:)';
        end_pos = end_points(i,:)';
        
        % Calculate progress along the line (0 to 1)
        total_distance = norm(end_pos - start_pos);
        if total_distance > 0
            traveled_distance = norm(current_pos - start_pos);
            progress_metrics(i,kk) = min(traveled_distance / total_distance, 1.0);
        else
            progress_metrics(i,kk) = 1.0;
        end
    end
    plot(t_sim, progress_metrics(i,:) * 100, [colors(i) '-'], 'LineWidth', 1.5);
end

xlabel('Time [s]'); ylabel('Progress [%]');
title('Individual Robot Progress Along Their Paths');
legend('Robot 1', 'Robot 2', 'Robot 3', 'Robot 4');
ylim([0, 110]);

% 4. Linear velocities
subplot(2,3,4);
hold on; grid on;
for i = 1:N
    v_data = u_sim(2*(i-1)+1, :);
    plot(t_sim(1:end-1), v_data, [colors(i) '-'], 'LineWidth', 1.5);
end
plot([t_sim(1), t_sim(end)], [desired_speed, desired_speed], 'k--', 'LineWidth', 2);
xlabel('Time [s]'); ylabel('Linear Velocity v');
title('Control Inputs: Linear Velocities');
legend('Robot 1', 'Robot 2', 'Robot 3', 'Robot 4', 'Desired Speed');
ylim([v_min-0.1, v_max+0.1]);

% 5. Headings over time
subplot(2,3,5);
hold on; grid on;
for i = 1:N
    theta_data = z_sim(3*i, :);
    plot(t_sim, theta_data, [colors(i) '-'], 'LineWidth', 1.5);
    
    % Plot desired heading for each robot
    line_vec = end_points(i,:) - start_points(i,:);
    desired_heading = atan2(line_vec(2), line_vec(1));
    plot([t_sim(1), t_sim(end)], [desired_heading, desired_heading], ...
         [colors(i) '--'], 'LineWidth', 1);
end

xlabel('Time [s]'); ylabel('Heading [rad]');
title('Robot Headings vs Time');
legend('Robot 1', 'Robot 2', 'Robot 3', 'Robot 4', ...
       'Desired 1', 'Desired 2', 'Desired 3', 'Desired 4', 'Location', 'best');

% 6. Distance between robots (formation maintenance)
subplot(2,3,6);
hold on; grid on;
pairwise_distances = zeros(N, N, N_sim+1);
mean_pairwise_errors = zeros(1, N_sim+1);

for kk = 1:N_sim+1
    % CORRECTED: Extract x,y positions for all robots
    positions = zeros(N, 2);
    desired_positions = zeros(N, 2);
    
    for i = 1:N
        idx = (i-1)*3 + (1:2);  % indices for x and y
        positions(i,:) = z_sim(idx, kk)';
        desired_positions(i,:) = z_des_history(idx, kk)';
    end
    
    current_dists = zeros(N, N);
    desired_dists = zeros(N, N);
    pairwise_errors = zeros(N, N);
    
    for i = 1:N
        for j = i+1:N
            current_dists(i,j) = norm(positions(i,:) - positions(j,:));
            desired_dists(i,j) = norm(desired_positions(i,:) - desired_positions(j,:));
            pairwise_errors(i,j) = abs(current_dists(i,j) - desired_dists(i,j));
        end
    end
    
    % Store all pairwise errors
    pairwise_distances(:,:,kk) = pairwise_errors;
    
    % Calculate mean of non-zero errors (only the upper triangle)
    non_zero_errors = pairwise_errors(pairwise_errors > 0);
    if ~isempty(non_zero_errors)
        mean_pairwise_errors(kk) = mean(non_zero_errors);
    else
        mean_pairwise_errors(kk) = 0;
    end
end

plot(t_sim, mean_pairwise_errors, 'm-', 'LineWidth', 2);
xlabel('Time [s]'); ylabel('Mean Pairwise Distance Error');
title('Formation Maintenance Quality');
grid on;

sgtitle('Multi-Robot Individual Trajectory Following');

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% -------------------Animation-------------------------%%

fprintf('Creating animation...\n');
figure('Position', [200, 200, 1000, 900]);
hold on; grid on;

% Plot individual desired trajectories
t_anim = linspace(0, Tf, 100);
for i = 1:N
    robot_traj = zeros(2, length(t_anim));
    for j = 1:length(t_anim)
        [~, centers] = get_desired_formation_at_time(t_anim(j), start_points, end_points, trajectory_duration, desired_speed);
        robot_traj(:,j) = centers(:,i);
    end
    plot(robot_traj(1,:), robot_traj(2,:), 'k--', 'LineWidth', 1, 'HandleVisibility', 'off');
end

% Plot start and end points
for i = 1:N
    plot(start_points(i,1), start_points(i,2), 'ks', 'MarkerSize', 10, 'LineWidth', 2, 'HandleVisibility', 'off');
    plot(end_points(i,1), end_points(i,2), 'k^', 'MarkerSize', 10, 'LineWidth', 2, 'HandleVisibility', 'off');
end

h_robots = gobjects(N,1);
h_trails = gobjects(N,1);
h_desired_current = gobjects(N,1);

colors = ['r', 'g', 'b', 'm'];
marker_size = 10;
line_width = 2;

% Initialize plots for each robot
for i = 1:N
    idx = (i-1)*3 + (1:2);
    
    % Robot actual trail (solid line)
    h_trails(i) = plot(z_sim(idx(1),1), z_sim(idx(2),1), [colors(i) '-'], ...
                      'LineWidth', 2, 'DisplayName', sprintf('Robot %d Path', i));
    
    % Robot current position (circle)
    h_robots(i) = plot(z_sim(idx(1),1), z_sim(idx(2),1), [colors(i) 'o'], ...
                      'MarkerSize', marker_size, 'LineWidth', 3, ...
                      'DisplayName', sprintf('Robot %d', i));
    
    % Desired current position (x marker)
    h_desired_current(i) = plot(z_des_history(idx(1),1), z_des_history(idx(2),1), ...
                               [colors(i) 'x'], 'MarkerSize', 8, 'LineWidth', 2, ...
                               'DisplayName', sprintf('Desired %d', i));
end

xlabel('X Position [m]'); 
ylabel('Y Position [m]');
title('Multi-Robot Line Trajectory Following');
legend('Location', 'best');
axis equal;

% Set appropriate axis limits
all_x = [z_sim(1:3:end,:), z_des_history(1:3:end,:)];
all_y = [z_sim(2:3:end,:), z_des_history(2:3:end,:)];
margin = 2.0;
xlim([min(all_x,[],'all')-margin, max(all_x,[],'all')+margin]);
ylim([min(all_y,[],'all')-margin, max(all_y,[],'all')+margin]);

% Animation loop
for k = 1:3:N_sim+1  % Show every 3rd frame for smoother animation
    current_time = t_sim(k);
    
    for i = 1:N
        idx = (i-1)*3 + (1:2);
        
        % Update robot position and trail
        set(h_robots(i), 'XData', z_sim(idx(1),k), 'YData', z_sim(idx(2),k));
        set(h_trails(i), 'XData', z_sim(idx(1),1:k), 'YData', z_sim(idx(2),1:k));
        
        % Update desired position
        set(h_desired_current(i), 'XData', z_des_history(idx(1),k), 'YData', z_des_history(idx(2),k));
    end
    
    % Update title with current time and progress
    progress = current_time / Tf * 100;
    title(sprintf('Line Trajectory Following (Time: %.1fs, Progress: %.0f%%)', ...
          current_time, progress));
    
    % Add text annotation for current average error
    current_errors = zeros(N,1);
    for i = 1:N
        idx = (i-1)*3 + (1:2);
        current_errors(i) = norm(z_sim(idx,k) - z_des_history(idx,k));
    end
    avg_error = mean(current_errors);
    
    if isempty(findobj('Type', 'text'))
        text(0.02, 0.98, sprintf('Average Error: %.3f m', avg_error), ...
             'Units', 'normalized', 'VerticalAlignment', 'top', ...
             'BackgroundColor', 'white', 'FontSize', 10);
    else
        annotation_text = findobj('Type', 'text');
        annotation_text.String = sprintf('Average Error: %.3f m', avg_error);
    end
    
    drawnow;
    pause(0.03);
end

fprintf('Animation completed.\n');

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% -------------------Performance Metrics--------------------------%%

fprintf('\n=== Performance Metrics ===\n');

% Final position errors
fprintf('Final Position Errors:\n');
total_error = 0;
for i = 1:N
    idx = (i-1)*3 + (1:2);
    final_error = norm(z_sim(idx,end) - z_des_history(idx,end));
    total_error = total_error + final_error;
    fprintf('  Robot %d: %.4f m\n', i, final_error);
end

fprintf('Average Final Error: %.4f m\n', total_error/N);

% Path completion
fprintf('\nPath Completion:\n');
for i = 1:N
    total_distance = norm(end_points(i,:) - start_points(i,:));
    traveled_distance = norm(z_sim((i-1)*3+(1:2),end) - start_points(i,:)');
    completion = min(traveled_distance / total_distance * 100, 100);
    fprintf('  Robot %d: %.1f%% completed\n', i, completion);
end

fprintf('\nSimulation completed successfully!\n');
