clear;
close all;
clc;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% ---------------------import libraries--------------------------%%
import casadi.*


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% ------------------------Dynamics------------------------------%%

% this dynamic using SX is only to use in casadi and different from matlab
% mathematic toolbox that we were using syms
% this is easier and better
N = 4;
nx = 3*N;
nu = 2*N;

x = SX.sym('x', nx, 1);
u = SX.sym('u', nu, 1);

f_expl = SX.zeros(nx,1);
for i = 1:N
    xi = x(3*(i-1)+1);
    yi = x(3*(i-1)+2);
    thi = x(3*(i-1)+3);
    vi = u(2*(i-1)+1);
    wi = u(2*(i-1)+2);

    f_expl(3*(i-1)+(1:3)) = [vi*cos(thi); vi*sin(thi); wi];
end

% CasADi function to evaluate dynamics (useful for simulation)
f_fun = Function('f_fun', {x, u}, {f_expl});

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% -----------------Lemniscate Trajectory Parameters-------------------%%

% Define lemniscate trajectory for the FORMATION CENTER
formation_center_params = struct();
formation_center_params.center = [0, 0];  % Initial center
formation_center_params.a = 50.0;         % Scale parameter for lemniscate
formation_center_params.b = 25.0;          % Scale parameter for lemniscate
formation_center_params.phase_shift = 0;
formation_center_params.angular_vel = 0.075;

% Define the square formation relative to the center
% Initial positions relative to center [0,0]
relative_positions = [1, -1;   % Robot 1: bottom-right
                      1,  1;   % Robot 2: top-right
                     -1, -1;   % Robot 3: bottom-left  
                     -1,  1];  % Robot 4: top-left

% Total simulation time
Tf = 80;             % total simulation time [s]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% -----------------Time-Varying Desired Position Function----------%%

% Function to compute desired formation at time t
get_desired_formation = @(t) get_desired_formation_at_time(t, formation_center_params, relative_positions);

% Test the function at initial time
[z_des_initial, center_des_initial] = get_desired_formation(0);

% Store for later use
z_des = z_des_initial;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% ------------------MPC Parameters------------------------------%%

N_horizon = 60;      % prediction horizon steps
dt = Tf / N_horizon; % sampling time

% Input limits (not enforced here, but values kept)
v_max = 2.0; w_max = 1.0;
v_min = -v_max; w_min = -w_max;

% initial state - use the square formation positions as initial positions
z0 = zeros(nx, 1);
for i = 1:N
    idx = (i-1)*3 + (1:3);
    
    % Calculate initial position based on formation
    [x_des, y_des, theta_des] = get_formation_point(formation_center_params, relative_positions(i,:), 0);
    
    z0(idx(1)) = x_des;  % x position
    z0(idx(2)) = y_des;  % y position
    z0(idx(3)) = theta_des;  % heading
end

% weights (quadratic weights)
Q_x = 4900.0; Q_y = 4900.0; Q_th = 3.0;
R_v = 2.25; R_w = 81.0;


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% -------------------pack casadi symbols----------------------------%
% Create acados model struct compatible with AcadosOcp
model = AcadosModel();
model.x = x;
model.u = u;
model.f_expl_expr = f_expl;
model.name = 'multi_unicycle';

%% --------------------Build Ocp--------------------------------------%%

ocp = AcadosOcp();
ocp.model = model;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% ------------------ Cost Function ---------------------------------%%

% Build weight matrices for each robot
Wx_robot = diag([Q_x, Q_y, Q_th]);
Wu_robot = diag([R_v, R_w]);

% Create block diagonal matrices for all robots
Wx = kron(eye(N), Wx_robot);
Wu = kron(eye(N), Wu_robot);

% Since we have time-varying reference, we'll use a different approach
% We'll create a parameter for the desired state that changes each MPC step

% Add parameter for time-varying reference
ocp.model.p = SX.sym('p', nx, 1);  % Parameter for desired state
z_des_param = ocp.model.p;

% 1. Initial Cost
ocp.cost.cost_type_0 = 'NONLINEAR_LS';
ocp.cost.W_0 = Wu;
ocp.cost.yref_0 = zeros(nu, 1);
ocp.model.cost_y_expr_0 = model.u;

% 2. Path Cost - use parameter for desired state
% Path cost: reference is included as parameter (p)
ocp.cost.cost_type = 'NONLINEAR_LS';
ocp.cost.W = blkdiag(Wx, Wu);

% Now, cost expression is "tracking error" directly
ocp.model.cost_y_expr = vertcat(model.x - z_des_param, model.u); %model.x changed to model.x - z_des_param

% Reference becomes zero (we track relative error, not absolute position)
ocp.cost.yref = zeros(nx + nu, 1);   


% 3. Terminal Cost
ocp.cost.cost_type_e = 'NONLINEAR_LS';
ocp.model.cost_y_expr_e = model.x - z_des_param; %this is also changed
ocp.cost.yref_e = zeros(nx,1);
ocp.cost.W_e = Wx;

%% ------------------ Horizon and Discretization ---------------------%%

ocp.solver_options.tf = Tf;
ocp.solver_options.N_horizon = N_horizon;

%% Constraints
ocp.constraints.x0 = z0;
ocp.constraints.lbu = repmat([v_min; w_min], N, 1);
ocp.constraints.ubu = repmat([v_max; w_max], N, 1);
ocp.constraints.idxbu = 0:(nu-1);

%% Solver options (same as before)
ocp.solver_options.nlp_solver_type = 'SQP_RTI';
ocp.solver_options.integrator_type = 'ERK'; 
ocp.solver_options.qp_solver = 'PARTIAL_CONDENSING_HPIPM'; 
ocp.solver_options.qp_solver_iter_max = 100; 
ocp.solver_options.qp_solver_tol_stat = 1e-6;
ocp.solver_options.qp_solver_tol_eq = 1e-6;
ocp.solver_options.qp_solver_tol_ineq = 1e-6;
ocp.solver_options.qp_solver_tol_comp = 1e-6;
ocp.solver_options.qp_solver_mu0 = 1e-2;
ocp.solver_options.qp_solver_cond_N = N_horizon;
ocp.solver_options.hessian_approx = 'GAUSS_NEWTON'; 
ocp.solver_options.ext_fun_compile_flags = '-O2'; 
ocp.solver_options.nlp_solver_max_iter = 50;
ocp.solver_options.nlp_solver_tol_stat = 1e-4;
ocp.solver_options.nlp_solver_tol_eq = 1e-4;
ocp.solver_options.nlp_solver_tol_ineq = 1e-4;
ocp.solver_options.nlp_solver_tol_comp = 1e-4;
ocp.solver_options.globalization = 'FIXED_STEP';
ocp.solver_options.levenberg_marquardt = 1e-2;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% -------------------Create Acados Solver-------------------------%%

acados_ocp_solver = AcadosOcpSolver(ocp);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% -------------------Simulation Setup-----------------------------%%

% Number of simulation steps
N_sim = 100;
t_sim = linspace(0, Tf, N_sim+1);

% Initialize simulation arrays
z_sim = zeros(nx, N_sim+1);
u_sim = zeros(nu, N_sim);
z_des_history = zeros(nx, N_sim+1);  % Store desired states over time
formation_center_history = zeros(2, N_sim+1);  % Store formation center over time
z_sim(:,1) = z0;

% Initialize cost function storage
cost_values = zeros(1, N_sim);
state_cost_values = zeros(1, N_sim);
control_cost_values = zeros(1, N_sim);
solver_status = zeros(1, N_sim);
solver_iterations = zeros(1, N_sim);
solver_times = zeros(1, N_sim);

% Create quadratic cost function for evaluation
stage_cost_fn = @(x, u, z_des_current) (x - z_des_current)' * Wx * (x - z_des_current) + u' * Wu * u;

% Initialize solver
acados_ocp_solver.set('constr_x0', z0);

% Set initial desired state
z_des_initial = get_desired_formation(0);
acados_ocp_solver.set('p', z_des_initial);
z_des_history(:,1) = z_des_initial;

% Calculate initial formation center
formation_center_history(:,1) = calculate_formation_center(z0);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% -------------------Main Simulation Loop-------------------------%%

fprintf('Starting MPC simulation with formation center lemniscate trajectory...\n');

for k = 1:N_sim
    current_time = t_sim(k);
    
    % Get desired formation at current time
    [z_des_current, center_current] = get_desired_formation(current_time);
    z_des_history(:,k) = z_des_current;
    formation_center_history(:,k) = center_current;
    
    % Set parameter (desired state) for current optimization
    acados_ocp_solver.set('p', z_des_current);
    
    % Set initial state constraint
    acados_ocp_solver.set('constr_x0', z_sim(:,k));
    
    % Solve OCP
    acados_ocp_solver.solve();
    
    % Get solver statistics
    status = acados_ocp_solver.get('status');
    sqp_iter = acados_ocp_solver.get('sqp_iter');
    time_tot = acados_ocp_solver.get('time_tot');
    
    solver_status(k) = status;
    solver_iterations(k) = sqp_iter;
    solver_times(k) = time_tot;
    
    if status ~= 0
        fprintf('Warning: acados returned status %d at step %d\n', status, k);
    end
    
    % Get optimal control input (first step)
    u_opt = acados_ocp_solver.get('u', 0);
    u_sim(:,k) = u_opt;
    
    % Calculate quadratic cost for current state and applied control
    current_total_cost = stage_cost_fn(z_sim(:,k), u_opt, z_des_current);
    cost_values(k) = current_total_cost;
    
    % Calculate state cost component
    state_cost_val = (z_sim(:,k) - z_des_current)' * Wx * (z_sim(:,k) - z_des_current);
    state_cost_values(k) = state_cost_val;
    
    % Calculate control cost component
    control_cost_val = u_opt' * Wu * u_opt;
    control_cost_values(k) = control_cost_val;
    
    % Simulate system forward (using 4th order Runge-Kutta)
    z_current = z_sim(:,k);
    
    % RK4 integration
    k1 = f_fun(z_current, u_opt);
    k2 = f_fun(z_current + 0.5*dt*k1, u_opt);
    k3 = f_fun(z_current + 0.5*dt*k2, u_opt);
    k4 = f_fun(z_current + dt*k3, u_opt);
    
    z_next = z_current + (dt/6) * (k1 + 2*k2 + 2*k3 + k4);
    z_sim(:,k+1) = full(z_next);
    
    % Print progress
    if mod(k, 10) == 0
        fprintf('Step %d/%d - Time: %.1fs - Cost: %.4f\n', ...
                k, N_sim, current_time, cost_values(k));
    end
end

% Get final desired state
[z_des_final, center_final] = get_desired_formation(t_sim(end));
z_des_history(:,end) = z_des_final;
formation_center_history(:,end) = center_final;

% Calculate final formation center
formation_center_history(:,end) = calculate_formation_center(z_sim(:,end));

fprintf('Simulation completed successfully!\n');



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% -------------------Helper Functions for Formation------------------%%

function [x, y, theta] = get_formation_point(center_params, relative_pos, t)
    % Calculate the formation center position on lemniscate
    center = center_params.center;
    a = center_params.a;
    b = center_params.b;
    phase_shift = center_params.phase_shift;
    angular_vel = center_params.angular_vel;
    
    % Parameter s goes from 0 to 2*pi
    s = phase_shift + angular_vel * t;
    
    % Lemniscate parametric equations for CENTER
    denom = 1 + sin(s)^2;
    center_x = center(1) + a * cos(s) / denom;
    center_y = center(2) + b * sin(s) * cos(s) / denom;
    
    % Calculate derivatives for center heading (tangent to the curve)
    dx_ds = -a * sin(s) / denom - a * cos(s) * (2 * sin(s) * cos(s)) / denom^2;
    dy_ds = b * (cos(s)^2 - sin(s)^2) / denom - b * sin(s) * cos(s) * (2 * sin(s) * cos(s)) / denom^2;
    
    % Desired heading for formation (tangent to the curve)
    formation_heading = atan2(dy_ds, dx_ds);
    
    % Robot position relative to moving center
    % We maintain the same relative positions but they rotate with the formation
    rel_x = relative_pos(1);
    rel_y = relative_pos(2);
    
    % If we want the formation to maintain orientation relative to trajectory:
    % Rotate relative positions by formation heading
    x = center_x + rel_x * cos(formation_heading) - rel_y * sin(formation_heading);
    y = center_y + rel_x * sin(formation_heading) + rel_y * cos(formation_heading);
    
    % Desired robot heading (same as formation heading for simplicity)
    % You could modify this if you want different robot orientations
    theta = formation_heading;
end

function [z_des, center_des] = get_desired_formation_at_time(t, center_params, relative_positions)
    N = size(relative_positions, 1);
    nx = 3*N;
    
    z_des = zeros(nx,1);
    
    % Calculate current center position on lemniscate
    center = center_params.center;
    a = center_params.a;
    b = center_params.b;
    phase_shift = center_params.phase_shift;
    angular_vel = center_params.angular_vel;
    
    s = phase_shift + angular_vel * t;
    denom = 1 + sin(s)^2;
    center_x = center(1) + a * cos(s) / denom;
    center_y = center(2) + b * sin(s) * cos(s) / denom;
    center_des = [center_x; center_y];
    
    % Calculate derivatives for center heading
    dx_ds = -a * sin(s) / denom - a * cos(s) * (2 * sin(s) * cos(s)) / denom^2;
    dy_ds = b * (cos(s)^2 - sin(s)^2) / denom - b * sin(s) * cos(s) * (2 * sin(s) * cos(s)) / denom^2;
    formation_heading = atan2(dy_ds, dx_ds);
    
    for i = 1:N
        % Robot position relative to moving center
        rel_x = relative_positions(i, 1);
        rel_y = relative_positions(i, 2);
        
        % Rotate relative positions by formation heading
        x_des = center_x + rel_x * cos(formation_heading) - rel_y * sin(formation_heading);
        y_des = center_y + rel_x * sin(formation_heading) + rel_y * cos(formation_heading);
        
        % Build the desired state vector for this robot
        idx = (i-1)*3 + (1:3);
        z_des(idx(1)) = x_des;    % desired x_i
        z_des(idx(2)) = y_des;    % desired y_i
        z_des(idx(3)) = formation_heading;    % desired heading (same as formation)
    end
end

function center = calculate_formation_center(z)
    % Calculate the current center of the formation from robot positions
    N = length(z) / 3;
    positions = zeros(2, N);
    
    for i = 1:N
        idx = (i-1)*3 + (1:2);
        positions(:, i) = z(idx);
    end
    
    center = mean(positions, 2);
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% -------------------Plotting Results-----------------------------%%


% Calculate desired formation center history for plotting
desired_center_history = zeros(2, N_sim+1);
for kk = 1:N_sim+1
    [~, desired_center_history(:,kk)] = get_desired_formation(t_sim(kk));
end

figure('Position', [100, 100, 1200, 1000]);

% 1. Trajectories in 2D space with formation center trajectory
subplot(2,3,1);
hold on; grid on;
colors = ['r', 'g', 'b', 'm'];

% Plot lemniscate trajectory for FORMATION CENTER
s_plot = linspace(0, 2*pi, 200);
center_x = zeros(size(s_plot));
center_y = zeros(size(s_plot));

for j = 1:length(s_plot)
    s_val = s_plot(j);
    denom = 1 + sin(s_val)^2;
    center_x(j) = formation_center_params.center(1) + formation_center_params.a * cos(s_val) / denom;
    center_y(j) = formation_center_params.center(2) + formation_center_params.b * sin(s_val) * cos(s_val) / denom;
end

plot(center_x, center_y, 'k--', 'LineWidth', 2, 'DisplayName', 'Desired Center Path');

% Plot formation center trajectory (actual)
plot(formation_center_history(1,:), formation_center_history(2,:), 'k-', 'LineWidth', 3, 'DisplayName', 'Actual Center');

% Plot robot trajectories
for i = 1:N
    idx = (i-1)*3 + (1:2);
    plot(z_sim(idx(1),:), z_sim(idx(2),:), [colors(i) '-'], 'LineWidth', 2, 'DisplayName', sprintf('Robot %d', i));
    plot(z_sim(idx(1),1), z_sim(idx(2),1), [colors(i) 'o'], 'MarkerSize', 8, 'LineWidth', 2, 'HandleVisibility', 'off');
    plot(z_des_history(idx(1),end), z_des_history(idx(2),end), [colors(i) 's'], 'MarkerSize', 10, 'LineWidth', 2, 'HandleVisibility', 'off');
end

% Plot initial and final formations
plot_formation_shape(z_sim(:,1), 'b--', 2);
plot_formation_shape(z_sim(:,end), 'r--', 2);
plot_formation_shape(z_des_history(:,end), 'g--', 2);

xlabel('X position'); ylabel('Y position');
title('Formation Center Following Lemniscate Trajectory');
legend('Location', 'best');
axis equal;

% 2. Position errors over time
subplot(2,3,2);
hold on; grid on;
pos_errors = zeros(N, N_sim+1);
for i = 1:N
    idx = (i-1)*3 + (1:2);
    for kk = 1:N_sim+1
        pos_errors(i,kk) = norm(z_sim(idx,kk) - z_des_history(idx,kk));
    end
    plot(t_sim, pos_errors(i,:), [colors(i) '-'], 'LineWidth', 1.5);
end
xlabel('Time [s]'); ylabel('Position Error');
title('Position Errors vs Time');
legend('Robot 1', 'Robot 2', 'Robot 3', 'Robot 4');

% 3. Formation center error over time
subplot(2,3,3);
hold on; grid on;
center_errors = zeros(1, N_sim+1);

for kk = 1:N_sim+1
    center_errors(kk) = norm(formation_center_history(:,kk) - desired_center_history(:,kk));
end

plot(t_sim, center_errors, 'k-', 'LineWidth', 2);
xlabel('Time [s]'); ylabel('Formation Center Error');
title('Formation Center Tracking Error');
grid on;

% 4. Linear velocities
subplot(2,3,4);
hold on; grid on;
for i = 1:N
    v_data = u_sim(2*(i-1)+1, :);
    plot(t_sim(1:end-1), v_data, [colors(i) '-'], 'LineWidth', 1.5);
end
xlabel('Time [s]'); ylabel('Linear Velocity v');
title('Control Inputs: Linear Velocities');
legend('Robot 1', 'Robot 2', 'Robot 3', 'Robot 4');
ylim([v_min-0.1, v_max+0.1]);

% 5. Formation shape maintenance error
subplot(2,3,5);
hold on; grid on;
formation_errors = zeros(1, N_sim+1);

for kk = 1:N_sim+1
    % Calculate current formation shape error
    current_error = 0;
    for i = 1:N
        idx = (i-1)*3 + (1:2);
        current_error = current_error + norm(z_sim(idx,kk) - z_des_history(idx,kk));
    end
    formation_errors(kk) = current_error / N;
end

plot(t_sim, formation_errors, 'm-', 'LineWidth', 2);
xlabel('Time [s]'); ylabel('Average Formation Error');
title('Formation Shape Maintenance');
grid on;

% 6. Parameter progress along lemniscate
subplot(2,3,6);
hold on; grid on;
parameter_progress = zeros(1, N_sim+1);

phase_shift = formation_center_params.phase_shift;
angular_vel = formation_center_params.angular_vel;

for kk = 1:N_sim+1
    current_time = t_sim(kk);
    parameter_progress(kk) = mod(phase_shift + angular_vel * current_time, 2*pi);
end

plot(t_sim, parameter_progress, 'b-', 'LineWidth', 2);
xlabel('Time [s]'); ylabel('Parameter Progress [rad]');
title('Formation Center Progress Along Lemniscate');
grid on;

sgtitle('Multi-Robot Formation Following Lemniscate Trajectory');

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% -------------------Helper function for plotting formation shape----%%

function plot_formation_shape(z, style, line_width)
    N = length(z) / 3;
    positions = zeros(2, N);
    
    for i = 1:N
        idx = (i-1)*3 + (1:2);
        positions(:, i) = z(idx);
    end
    
    % Connect robots in order to show formation shape
    plot([positions(1,:), positions(1,1)], [positions(2,:), positions(2,1)], ...
         style, 'LineWidth', line_width, 'HandleVisibility', 'off');
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% -------------------Animation-------------------------%%

fprintf('Creating animation...\n');
figure('Position', [200, 200, 1000, 900]);
hold on; grid on;

% Plot lemniscate trajectory for formation center
s_anim = linspace(0, 2*pi, 200);
center_x_anim = zeros(size(s_anim));
center_y_anim = zeros(size(s_anim));

for j = 1:length(s_anim)
    s_val = s_anim(j);
    denom = 1 + sin(s_val)^2;
    center_x_anim(j) = formation_center_params.center(1) + formation_center_params.a * cos(s_val) / denom;
    center_y_anim(j) = formation_center_params.center(2) + formation_center_params.b * sin(s_val) * cos(s_val) / denom;
end

plot(center_x_anim, center_y_anim, 'k--', 'LineWidth', 2, 'DisplayName', 'Desired Center Path');

h_robots = gobjects(N,1);
h_trails = gobjects(N,1);
h_desired_current = gobjects(N,1);
h_formation_center = gobjects(1,1);
h_desired_center = gobjects(1,1);
h_formation_shape = gobjects(1,1);
h_desired_formation_shape = gobjects(1,1);

colors = ['r', 'g', 'b', 'm'];
marker_size = 10;
line_width = 2;

% Initialize plots for each robot
for i = 1:N
    idx = (i-1)*3 + (1:2);
    
    % Robot actual trail (solid line)
    h_trails(i) = plot(z_sim(idx(1),1), z_sim(idx(2),1), [colors(i) '-'], ...
                      'LineWidth', 1, 'DisplayName', sprintf('Robot %d Path', i));
    
    % Robot current position (circle)
    h_robots(i) = plot(z_sim(idx(1),1), z_sim(idx(2),1), [colors(i) 'o'], ...
                      'MarkerSize', marker_size, 'LineWidth', 3, ...
                      'DisplayName', sprintf('Robot %d', i));
    
    % Desired current position (x marker)
    h_desired_current(i) = plot(z_des_history(idx(1),1), z_des_history(idx(2),1), ...
                               [colors(i) 'x'], 'MarkerSize', 8, 'LineWidth', 2, ...
                               'DisplayName', sprintf('Desired %d', i));
end

% Formation center and shape
h_formation_center = plot(formation_center_history(1,1), formation_center_history(2,1), ...
                         'ko', 'MarkerSize', 12, 'LineWidth', 3, 'DisplayName', 'Formation Center');
h_desired_center = plot(desired_center_history(1,1), desired_center_history(2,1), ...
                       'k+', 'MarkerSize', 12, 'LineWidth', 3, 'DisplayName', 'Desired Center');

% Initial formation shapes
h_formation_shape = plot_formation_shape_animated(z_sim(:,1), 'b-', 2);
h_desired_formation_shape = plot_formation_shape_animated(z_des_history(:,1), 'g--', 2);

xlabel('X Position [m]'); 
ylabel('Y Position [m]');
title('Formation Following Lemniscate Trajectory');
legend('Location', 'best');
axis equal;

% Set appropriate axis limits - FIXED VERSION
all_x_data = [];
all_y_data = [];

% Collect all x coordinates
for i = 1:N
    idx_x = (i-1)*3 + 1;
    all_x_data = [all_x_data, z_sim(idx_x,:), z_des_history(idx_x,:)];
end
all_x_data = [all_x_data, center_x_anim, desired_center_history(1,:)];

% Collect all y coordinates
for i = 1:N
    idx_y = (i-1)*3 + 2;
    all_y_data = [all_y_data, z_sim(idx_y,:), z_des_history(idx_y,:)];
end
all_y_data = [all_y_data, center_y_anim, desired_center_history(2,:)];

margin = 5.0;
xlim([min(all_x_data) - margin, max(all_x_data) + margin]);
ylim([min(all_y_data) - margin, max(all_y_data) + margin]);

% Animation loop
for k = 1:3:N_sim+1  % Show every 3rd frame for smoother animation
    current_time = t_sim(k);
    
    for i = 1:N
        idx = (i-1)*3 + (1:2);
        
        % Update robot position and trail
        set(h_robots(i), 'XData', z_sim(idx(1),k), 'YData', z_sim(idx(2),k));
        set(h_trails(i), 'XData', z_sim(idx(1),1:k), 'YData', z_sim(idx(2),1:k));
        
        % Update desired position
        set(h_desired_current(i), 'XData', z_des_history(idx(1),k), 'YData', z_des_history(idx(2),k));
    end
    
    % Update formation center
    set(h_formation_center, 'XData', formation_center_history(1,k), 'YData', formation_center_history(2,k));
    set(h_desired_center, 'XData', desired_center_history(1,k), 'YData', desired_center_history(2,k));
    
    % Update formation shapes
    delete(h_formation_shape);
    delete(h_desired_formation_shape);
    h_formation_shape = plot_formation_shape_animated(z_sim(:,k), 'b-', 2);
    h_desired_formation_shape = plot_formation_shape_animated(z_des_history(:,k), 'g--', 2);
    
    % Update title with current time
    title(sprintf('Formation Following Lemniscate (Time: %.1fs)', current_time));
    
    % Add text annotation for current errors
    current_errors = zeros(N,1);
    for i = 1:N
        idx = (i-1)*3 + (1:2);
        current_errors(i) = norm(z_sim(idx,k) - z_des_history(idx,k));
    end
    avg_error = mean(current_errors);
    center_error = norm(formation_center_history(:,k) - desired_center_history(:,k));
    
    if isempty(findobj('Type', 'text'))
        text(0.02, 0.98, sprintf('Avg Robot Error: %.3f m\nCenter Error: %.3f m', avg_error, center_error), ...
             'Units', 'normalized', 'VerticalAlignment', 'top', ...
             'BackgroundColor', 'white', 'FontSize', 10);
    else
        annotation_text = findobj('Type', 'text');
        annotation_text.String = sprintf('Avg Robot Error: %.3f m\nCenter Error: %.3f m', avg_error, center_error);
    end
    
    drawnow;
    pause(0.03);
end

fprintf('Animation completed.\n');

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% -------------------Helper function for animated formation shape---%%

function h = plot_formation_shape_animated(z, style, line_width)
    N = length(z) / 3;
    positions = zeros(2, N);
    
    for i = 1:N
        idx = (i-1)*3 + (1:2);
        positions(:, i) = z(idx);
    end
    
    % Connect robots in order to show formation shape
    h = plot([positions(1,:), positions(1,1)], [positions(2,:), positions(2,1)], ...
             style, 'LineWidth', line_width, 'HandleVisibility', 'off');
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% -------------------Performance Metrics--------------------------%%

fprintf('\n=== Performance Metrics ===\n');

% Final position errors
fprintf('Final Position Errors:\n');
total_error = 0;
for i = 1:N
    idx = (i-1)*3 + (1:2);
    final_error = norm(z_sim(idx,end) - z_des_history(idx,end));
    total_error = total_error + final_error;
    fprintf('  Robot %d: %.4f m\n', i, final_error);
end

fprintf('Average Final Robot Error: %.4f m\n', total_error/N);

% Formation center error
final_center_error = norm(formation_center_history(:,end) - desired_center_history(:,end));
fprintf('Final Formation Center Error: %.4f m\n', final_center_error);

% Formation shape maintenance
fprintf('\nFormation Shape Maintenance:\n');
initial_formation_size = calculate_formation_size(z_sim(:,1));
final_formation_size = calculate_formation_size(z_sim(:,end));
desired_formation_size = calculate_formation_size(z_des_history(:,end));

fprintf('  Initial formation size: %.4f m\n', initial_formation_size);
fprintf('  Final formation size: %.4f m\n', final_formation_size);
fprintf('  Desired formation size: %.4f m\n', desired_formation_size);
fprintf('  Size maintenance error: %.4f m\n', abs(final_formation_size - desired_formation_size));

% Number of lemniscate loops completed
angular_vel = formation_center_params.angular_vel;
loops_completed = (angular_vel * Tf) / (2*pi);
fprintf('Formation Center completed %.2f loops around lemniscate\n', abs(loops_completed));

fprintf('\nSimulation completed successfully!\n');

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% -------------------Helper function for formation size------------%%

function size_val = calculate_formation_size(z)
    % Calculate the size of the formation as average distance from center
    N = length(z) / 3;
    positions = zeros(2, N);
    
    for i = 1:N
        idx = (i-1)*3 + (1:2);
        positions(:, i) = z(idx);
    end
    
    center = mean(positions, 2);
    distances = zeros(1, N);
    
    for i = 1:N
        distances(i) = norm(positions(:, i) - center);
    end
    
    size_val = mean(distances);
end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
